/* Interface */
#define function getMerkleRoot() view returns (bytes32)
#define function getTokenAddress() view returns (address)

#define function isClaimed(uint256) view returns (bool)
#define function claim(uint256,address,uint256,bytes32[]) nonpayable returns ()

/* Storage Slots */
#define constant CLAIMED_BIT_MAP_SLOT = FREE_STORAGE_POINTER()  // 0x00
#define constant TOKEN_ADDR_SLOT = FREE_STORAGE_POINTER()       // 0x20
#define constant MERKLE_ROOT_SLOT = FREE_STORAGE_POINTER()      // 0x40

/* Methods */

#define macro GET_MERKLE_ROOT() = takes (0) returns (0) {
    // Load value from storage.
    [MERKLE_ROOT_SLOT]       // [ptr]
    sload               // [value]

    // Store value in memory.
    0x00 mstore

    // Return value
    0x20 0x00 return
}

#define macro GET_TOKEN_ADDR() = takes (0) returns (0) {
    // Load value from storage.
    [TOKEN_ADDR_SLOT] sload
    // Store value in memory.
    0x00 mstore
    // Return value
    0x20 0x00 return
}

#define macro IS_CLAIMED() = takes (0) returns (0) {
    // Load first argument from calldata
    0x04                        // [0x04]
    calldataload                // [value]
}

#define macro __UTIL_SET_CLAIMED() = takes (0) returns (0) {
    // Load first argument from calldata
    0x04                        // [0x04]
    calldataload                // [arg0]

    // index / 256
    0x100 dup2 div              // [index, arg0]

    // Lookup
    0x00 mstore                 // [arg0]
    [CLAIMED_BIT_MAP_SLOT] 0x20 mstore
    0x40 0x00 sha3              // [key(claimed[index]), arg0]
    
    // Load
    dup1 sload                  // [claimed[index], key(claimed[index]), arg0]

    // index % 256                 [claimed[index], key(claimed[index]), arg0]
    0x1 0x100 dup5 mod shl      // [shift, claimed[index], key(claimed[index]), arg0]
    or                          // [masked, key(claimed[to]), arg0]

    // Update
    swap1 sstore                // [arg0]

    // Pop
    pop                         // []
}

/* Constructor */
// constructor(address, merkleRoot)
#define macro CONSTRUCTOR() = takes (0) returns (0) {
    // Copy the first argument into memory
    0x20                        // [size] - byte size to copy
    0x40 codesize sub           // [offset, size] - offset in the code to copy from
    0x00                        // [mem, offset, size] - offset in memory to copy to
    codecopy                    // []

    // Store the first argument in storage
    0x00 mload                  // [arg1]
    [TOKEN_ADDR_SLOT]           // [TOKEN_ADDR, arg1]
    sstore                      // []

    // Copy the second argument into memory
    0x20                        // [size] - byte size to copy
    0x20 codesize sub           // [offset, size] - offset in the code to copy from
    0x00                        // [mem, offset, size] - offset in memory to copy to
    codecopy                    // []

    // Store the second argument in storage
    0x00 mload                  // [arg2]
    [MERKLE_ROOT_SLOT]          // [CONSTRUCTOR_ARG_TWO, arg2]
    sstore                      // []
}

#define macro MAIN() = takes (0) returns (0) {
    // Identify which function is being called.
    0x00 calldataload 0xE0 shr
    dup1 __FUNC_SIG(getMerkleRoot) eq getMerkleRoot jumpi
    dup1 __FUNC_SIG(getTokenAddress) eq getTokenAddress jumpi
    dup1 __FUNC_SIG(isClaimed) eq isClaimed jumpi

    getMerkleRoot:
        GET_MERKLE_ROOT()
    getTokenAddress:
        GET_TOKEN_ADDR()
    isClaimed:
        IS_CLAIMED()

    0x00 0x00 revert
}